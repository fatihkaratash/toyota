# Main Application (Coordinator) - Toyota Financial Data Platform

---

## 1. 📋 Project Overview

The **Main Application (Coordinator)** is the core component and central orchestrator of the Toyota Financial Data Platform. It's responsible for managing connections to external market data providers, processing this data, and handling the internal data flow within the platform. This microservice is built using Spring Boot, emphasizing reliability, extensibility, and production-readiness.

### 1.1. Position in Overall Architecture

The application sits centrally, ingesting raw data and distributing processed data:


---

## 2. 🎯 Core Functionalities

This application performs the following key operations:

*   **Dynamic Subscriber Management**: Dynamically loads and manages external subscriber classes (for TCP and REST providers) based on configuration.
*   **Data Ingestion**: Connects to various data providers (TCP and REST) and listens for streaming rate updates.
*   **Data Validation**: Implements validation rules for incoming rates (e.g., deviation checks, timestamp validity, bid/ask spread).
*   **Rate Calculation**: Calculates derived currency rates in real-time using configurable scripting engines (Groovy, JavaScript, or Java).
*   **Caching**: Caches both raw and calculated currency rates using Redis (primary) or Hazelcast (optional).
*   **Data Publishing**: Streams processed and validated rates to a Kafka topic for consumption by other services.
*   **Resilience & Fault Tolerance**: Implements health checks, circuit breaker patterns, and retry mechanisms.
*   **Monitoring & Logging**: Provides comprehensive logging for data flows, events, and system health.

---

## 3. 💡 How It Works - Key Mechanisms

### 3.1. Dynamic Subscriber System
*   Reads subscriber definitions from `subscribers.json` at startup.
*   Utilizes `DynamicClassLoader` and reflection to load and instantiate specified subscriber classes (`TcpRateSubscriber`, `RestRateSubscriber`).

### 3.2. Coordinator Pattern
The `MainCoordinator` orchestrates the primary workflow:
1.  Initializes and starts all configured subscribers.
2.  Receives raw rate data from subscribers via `PlatformCallback`.
3.  Passes rates to `RateValidationService` for validation (e.g., <1% deviation from the previous rate).
4.  If valid, caches the raw rate.
5.  Triggers the `RateCalculator` to compute derived rates.
6.  Caches the calculated rates.
7.  Publishes processed rates to Kafka via `RateProducer`.

### 3.3. Rate Calculation Engine
*   Supports dynamic calculation formulas provided externally.
*   Offers flexibility with multiple scripting engines:
    *   **Groovy**: Leverages `GroovyScriptEngine` for dynamic Groovy script execution (e.g., `eurtry.groovy`).
    *   **JavaScript**: Uses GraalVM or Nashorn via `JavaScriptEngine` for JS-based formulas.
    *   **Java**: Allows runtime compilation and loading of Java-based formula classes (e.g., `gbptry.java` as a dynamic script, or static formulas like `EurTryFormula.java`).
*   **Dependency Awareness**: When raw data from a platform is updated, the system identifies which derived calculations depend on it and triggers their re-computation.

### 3.4. Cache Layer
*   Primarily uses Redis (via `RedisRateCache`) for storing real-time raw and calculated rates.
*   Hazelcast (via `HazelcastRateCache`) is an optional alternative.
*   Configuration is managed in `CacheConfig.java` and `application.properties`.

### 3.5. Kafka Producer
*   Streams processed `RateMessage` objects to a predefined Kafka topic using `KafkaRateProducer`.
*   Configuration is managed in `KafkaConfig.java` and `application.properties`.

---

## 4. 🔗 Service Communication & Infrastructure

### 4.1. Service Communication Patterns

*   **TCP Provider Subscription**:
    *   Managed by `TcpRateSubscriber`.
    *   Establishes socket-based connections (e.g., to `tcp-rate-provider`).
    *   Maintains persistent connections with keep-alive and implements reconnection logic with exponential backoff.
    *   Example subscription protocol: `subscribe|PF1_USDTRY`
*   **REST Provider Integration**:
    *   Managed by `RestRateSubscriber`.
    *   Polls REST endpoints (e.g., `GET /api/rates/{rateName}` from `rest-rate-provider`) at configurable intervals.
    *   Uses Spring's `RestTemplate` integrated with circuit breaker patterns.

### 4.2. Infrastructure Connectivity

Configuration for external services is typically found in `application.properties`:

*   **Redis:**
    ```properties
    spring.redis.host=redis
    spring.redis.port=6379
    # ... other Redis settings
    ```
*   **Kafka:**
    ```properties
    spring.kafka.bootstrap-servers=kafka:9092
    spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
    spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer # Or a custom RateMessage serializer
    # ... other Kafka settings
    ```

---

## 5. 🌊 Data Flow Summary

The general data processing pipeline is:


---

## 6. 🧮 Rate Calculation Logic

The system is designed to calculate derived rates (e.g., EUR/TRY, GBP/TRY) from base rates obtained from providers (e.g., USD/TRY, EUR/USD, GBP/USD).

### 6.1. General Principles
*   Raw data for symbols like USD/TRY, EUR/USD, GBP/USD are directly sourced from providers.
*   Derived rates like EUR/TRY and GBP/TRY are calculated using formulas.
*   Formulas can be dynamically provided as Java classes, JavaScript, or Groovy scripts.

### 6.2. Example Calculation Formulas:

Let PF1 and PF2 be two different data providers.

*   **USD/TRY Calculation:**
    *   The BID and ASK values for USD/TRY are the average of the values from available platforms.
    *   `USDTRY.bid = (PF1_USDTRY.bid + PF2_USDTRY.bid) / 2`
    *   `USDTRY.ask = (PF1_USDTRY.ask + PF2_USDTRY.ask) / 2`
    *   _Example:_ `Bid: (33.6 + 34.8) / 2 = 34.2`, `Ask: (35.9 + 35.1) / 2 = 35.5`

*   **USD Mid Rate (usdmid) Calculation (used for cross rates):**
    *   `usdmid = (USDTRY.bid + USDTRY.ask) / 2`
    *   _Example (using calculated USDTRY averages):_ `(34.2 + 35.5) / 2 = 34.85`
        *(Note: The example in the prompt used ((33.6+34.8)/2+(35.9+35.1)/2)/2=34.85 which is the same)*

*   **EUR/TRY Calculation:**
    *   `EURTRY.bid = usdmid * ((PF1_EURUSD.bid + PF2_EURUSD.bid) / 2)`
    *   `EURTRY.ask = usdmid * ((PF1_EURUSD.ask + PF2_EURUSD.ask) / 2)`
    *   _Example (using usdmid=34.85 from above, and example EURUSD values):_
        *   `Avg EURUSD.bid = (1.022 + 1.037) / 2 = 1.0295`
        *   `Avg EURUSD.ask = (1.045 + 1.041) / 2 = 1.043`
        *   `EURTRY.bid = 34.85 * 1.0295 = 35.878075`
        *   `EURTRY.ask = 34.85 * 1.043 = 36.34855`
        *(Note: Original example used 34.58 for usdmid, this uses the consistent 34.85)*


*   **GBP/TRY Calculation:**
    *   `GBPTRY.bid = usdmid * ((PF1_GBPUSD.bid + PF2_GBPUSD.bid) / 2)`
    *   `GBPTRY.ask = usdmid * ((PF1_GBPUSD.ask + PF2_GBPUSD.ask) / 2)`
    *   _Example (using usdmid=34.85 from above, and example GBPUSD values):_
        *   `Avg GBPUSD.bid = (1.251 + 1.259) / 2 = 1.255`
        *   `Avg GBPUSD.ask = (1.2645 + 1.2615) / 2 = 1.263`
        *   `GBPTRY.bid = 34.85 * 1.255 = 43.73675`
        *   `GBPTRY.ask = 34.85 * 1.263 = 44.01555`
        *(Note: Original example used 34.58 for usdmid, this uses the consistent 34.85)*


---

## 7. 🗂️ Project Structure & Class Responsibilities


---

## 8. ⚙️ Configuration

Key configurations are managed through property files and JSON files:

### 8.1. Configuration Files:
*   `application.properties` (and profile-specific variants): For Spring Boot, cache (Redis/Hazelcast), Kafka, circuit breaker, and retry settings.
*   `subscribers.json`: Defines the external data providers to connect to.
*   `calculation-config.json`: Specifies configurations for the calculation engine, including paths to dynamic scripts or parameters for formulas.
*   `log4j2.xml` (or `logback.xml`): Configures logging levels and appenders.

### 8.2. Key Configuration Parameters:

| Parameter             | Location                | Description                                      |
| :-------------------- | :---------------------- | :----------------------------------------------- |
| Cache Settings        | `application.properties`| Host, port, and other settings for Redis/Hazelcast |
| Kafka Broker Info     | `application.properties`| Kafka bootstrap servers and producer/consumer props|
| Circuit Breaker       | `application.properties`| Thresholds, timeouts for circuit breaker         |
| Retry Policy          | `application.properties`| Max attempts, backoff for retry mechanisms       |
| Subscriber Definitions| `subscribers.json`      | List of external data providers and their types  |
| Calculation Formulas  | `calculation-config.json` / `scripts/` | Paths to scripts or formula definitions    |

### 8.3. Sample `subscribers.json`:
```json
[
    {"type": "tcp", "name": "ProviderTCP1", "host": "tcp-provider-alpha", "port": 8080, "subscribedSymbols": ["PF1_USDTRY", "PF1_EURUSD"]},
    {"type": "rest", "name": "ProviderREST1", "url": "http://rest-provider-beta:8081/api/rates", "pollIntervalMs": 5000, "subscribedSymbols": ["PF2_USDTRY", "PF2_GBPUSD"]}
]